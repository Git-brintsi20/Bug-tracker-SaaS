# üöÄ Bug Tracker SaaS - Complete Execution Plan

## üìä Current Status Analysis

### ‚úÖ What's Already Done:
- **Frontend UI Components** (Generated by Vercel v0):
  - Landing page with modern animations
  - Dashboard layouts
  - Auth pages (login, signup, forgot-password)
  - Issues/Bugs page with table view
  - Team management page
  - UI components library (shadcn/ui)
  - Navbar and Sidebar components
  - Modal components (bug-detail-modal)
  - Skeleton loaders

- **Dependencies Installed**:
  - Next.js 16.0.10
  - React 19.2.0
  - Framer Motion (for animations)
  - Form handling (react-hook-form, zod)
  - UI components (Radix UI, shadcn/ui)

### ‚ùå What's Missing (Everything Backend):
- **No backend services** - Auth, Bug, Notification microservices
- **No database** - Prisma schema, PostgreSQL setup
- **No API integration** - Frontend shows mock data only
- **No real-time features** - Socket.io not implemented
- **No authentication logic** - JWT, OAuth not implemented
- **No caching layer** - Redis not setup
- **No Docker setup** - No containerization
- **No proper monorepo structure**

### üîç Environment File Analysis:
Current `.env` has mixed backend credentials:
- MongoDB URI (we need PostgreSQL instead)
- JWT secrets (good, can reuse)
- File upload settings
- API URL points to localhost:5000 (backend doesn't exist yet)

---

## üìã DETAILED EXECUTION PLAN

### üü¢ **PHASE 1: Project Setup & Infrastructure** (Days 1-2)

#### Task 1.1: Reorganize Project Structure
```bash
# Create monorepo structure
bug-tracker-saas/
‚îú‚îÄ‚îÄ client/                    # Move current Next.js app here
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ auth-service/
‚îÇ   ‚îú‚îÄ‚îÄ bug-service/
‚îÇ   ‚îî‚îÄ‚îÄ notification-service/
‚îú‚îÄ‚îÄ prisma/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ docker-compose.prod.yml
‚îî‚îÄ‚îÄ README.md
```

**Action Items:**
1. Create new folder structure
2. Move current app to `/client` folder
3. Create skeleton for each microservice

#### Task 1.2: Environment Variables Setup
Create separate `.env` files:

**Root `.env`** (for Docker):
```env
# Database
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=bugtracker
POSTGRES_PORT=5432

# Redis
REDIS_PORT=6379

# Service Ports
AUTH_SERVICE_PORT=5001
BUG_SERVICE_PORT=5002
NOTIFICATION_SERVICE_PORT=5003
CLIENT_PORT=3000
```

**`/services/auth-service/.env`**:
```env
PORT=5001
NODE_ENV=development
DATABASE_URL=postgresql://postgres:postgres@postgres:5432/bugtracker
JWT_SECRET=dcae56f31adcb075c3c3d9e828ec34098fd0ae3f64287381bf569f04879c9ba8
JWT_REFRESH_SECRET=8f11508e3e76a8b6b94270780e18247c6932e7e72c52ea674884b47e2b85c5f1
JWT_EXPIRE=15m
JWT_REFRESH_EXPIRE=7d

# OAuth
GITHUB_CLIENT_ID=your-github-client-id
GITHUB_CLIENT_SECRET=your-github-secret
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-secret
OAUTH_CALLBACK_URL=http://localhost:3000/auth/oauth/callback
```

**`/services/bug-service/.env`**:
```env
PORT=5002
NODE_ENV=development
DATABASE_URL=postgresql://postgres:postgres@postgres:5432/bugtracker
REDIS_URL=redis://redis:6379
JWT_SECRET=dcae56f31adcb075c3c3d9e828ec34098fd0ae3f64287381bf569f04879c9ba8
AUTH_SERVICE_URL=http://auth-service:5001
NOTIFICATION_SERVICE_URL=http://notification-service:5003

# File Upload
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=5242880
ALLOWED_FILE_TYPES=image/jpeg,image/png,image/gif,application/pdf
```

**`/services/notification-service/.env`**:
```env
PORT=5003
NODE_ENV=development
REDIS_URL=redis://redis:6379
JWT_SECRET=dcae56f31adcb075c3c3d9e828ec34098fd0ae3f64287381bf569f04879c9ba8
CORS_ORIGIN=http://localhost:3000
```

**`/client/.env.local`**:
```env
NEXT_PUBLIC_API_URL=http://localhost:5002/api
NEXT_PUBLIC_AUTH_URL=http://localhost:5001/api
NEXT_PUBLIC_SOCKET_URL=http://localhost:5003
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

#### Task 1.3: Docker Compose Setup
Create `docker-compose.yml`:
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    container_name: bugtracker-postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: bugtracker
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - bugtracker-network

  redis:
    image: redis:7.2-alpine
    container_name: bugtracker-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - bugtracker-network

  auth-service:
    build:
      context: ./services/auth-service
      dockerfile: Dockerfile
    container_name: auth-service
    ports:
      - "5001:5001"
    env_file:
      - ./services/auth-service/.env
    depends_on:
      - postgres
    networks:
      - bugtracker-network
    volumes:
      - ./services/auth-service:/app
      - /app/node_modules

  bug-service:
    build:
      context: ./services/bug-service
      dockerfile: Dockerfile
    container_name: bug-service
    ports:
      - "5002:5002"
    env_file:
      - ./services/bug-service/.env
    depends_on:
      - postgres
      - redis
    networks:
      - bugtracker-network
    volumes:
      - ./services/bug-service:/app
      - /app/node_modules
      - uploads:/app/uploads

  notification-service:
    build:
      context: ./services/notification-service
      dockerfile: Dockerfile
    container_name: notification-service
    ports:
      - "5003:5003"
    env_file:
      - ./services/notification-service/.env
    depends_on:
      - redis
    networks:
      - bugtracker-network
    volumes:
      - ./services/notification-service:/app
      - /app/node_modules

  client:
    build:
      context: ./client
      dockerfile: Dockerfile
    container_name: client
    ports:
      - "3000:3000"
    env_file:
      - ./client/.env.local
    depends_on:
      - auth-service
      - bug-service
      - notification-service
    networks:
      - bugtracker-network
    volumes:
      - ./client:/app
      - /app/node_modules
      - /app/.next

volumes:
  postgres_data:
  redis_data:
  uploads:

networks:
  bugtracker-network:
    driver: bridge
```

---

### üü° **PHASE 2: Database Setup (Prisma)** (Day 3)

#### Task 2.1: Initialize Prisma
```bash
cd prisma
npm init -y
npm install prisma @prisma/client
npx prisma init
```

#### Task 2.2: Create Prisma Schema
Copy the complete schema from README into `prisma/schema.prisma`

#### Task 2.3: Create Migrations
```bash
npx prisma migrate dev --name init
npx prisma generate
```

#### Task 2.4: Create Seed File
Create `prisma/seed.ts` with sample data:
```typescript
import { PrismaClient } from '@prisma/client'
import bcrypt from 'bcryptjs'

const prisma = new PrismaClient()

async function main() {
  // Create test user
  const hashedPassword = await bcrypt.hash('TestPass123!', 10)
  
  const user = await prisma.user.create({
    data: {
      email: 'admin@bugtracker.com',
      username: 'admin',
      password: hashedPassword,
      firstName: 'Admin',
      lastName: 'User',
      emailVerified: true,
    },
  })

  // Create test organization
  const org = await prisma.organization.create({
    data: {
      name: 'Test Organization',
      slug: 'test-org',
      description: 'Sample organization',
    },
  })

  // Add user as admin
  await prisma.organizationMember.create({
    data: {
      userId: user.id,
      organizationId: org.id,
      role: 'ADMIN',
    },
  })

  console.log('‚úÖ Database seeded successfully')
}

main()
  .catch((e) => {
    console.error(e)
    process.exit(1)
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

---

### üü† **PHASE 3: Auth Service Implementation** (Days 4-5)

#### Task 3.1: Setup Express Server
```bash
cd services/auth-service
npm init -y
npm install express cors helmet dotenv bcryptjs jsonwebtoken passport passport-github2 passport-google-oauth20 @prisma/client
npm install -D typescript @types/express @types/node @types/bcryptjs @types/jsonwebtoken ts-node-dev
```

#### Task 3.2: Project Structure
```
auth-service/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authController.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userController.ts
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errorHandler.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authRoutes.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userRoutes.ts
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jwt.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ oauth.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts
‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îî‚îÄ‚îÄ server.ts
‚îú‚îÄ‚îÄ prisma/
‚îÇ   ‚îî‚îÄ‚îÄ schema.prisma (symlink to root)
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ tsconfig.json
```

#### Task 3.3: Key Implementation Files

**`src/utils/jwt.ts`**:
```typescript
import jwt from 'jsonwebtoken'

export const generateAccessToken = (userId: string) => {
  return jwt.sign({ userId }, process.env.JWT_SECRET!, {
    expiresIn: process.env.JWT_EXPIRE,
  })
}

export const generateRefreshToken = (userId: string) => {
  return jwt.sign({ userId }, process.env.JWT_REFRESH_SECRET!, {
    expiresIn: process.env.JWT_REFRESH_EXPIRE,
  })
}

export const verifyToken = (token: string) => {
  return jwt.verify(token, process.env.JWT_SECRET!)
}
```

**`src/middleware/auth.ts`**:
```typescript
import { Request, Response, NextFunction } from 'express'
import { verifyToken } from '../utils/jwt'

export const authenticate = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '')
    
    if (!token) {
      return res.status(401).json({ error: 'No token provided' })
    }

    const decoded = verifyToken(token) as { userId: string }
    req.userId = decoded.userId
    
    next()
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' })
  }
}
```

**`src/controllers/authController.ts`**:
```typescript
import { Request, Response } from 'express'
import { PrismaClient } from '@prisma/client'
import bcrypt from 'bcryptjs'
import { generateAccessToken, generateRefreshToken } from '../utils/jwt'

const prisma = new PrismaClient()

export const register = async (req: Request, res: Response) => {
  try {
    const { email, username, password, firstName, lastName } = req.body

    // Check if user exists
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [{ email }, { username }],
      },
    })

    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' })
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10)

    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        username,
        password: hashedPassword,
        firstName,
        lastName,
      },
      select: {
        id: true,
        email: true,
        username: true,
        firstName: true,
        lastName: true,
        createdAt: true,
      },
    })

    // Generate tokens
    const accessToken = generateAccessToken(user.id)
    const refreshToken = generateRefreshToken(user.id)

    res.status(201).json({
      user,
      accessToken,
      refreshToken,
    })
  } catch (error) {
    console.error('Register error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

export const login = async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body

    // Find user
    const user = await prisma.user.findUnique({
      where: { email },
    })

    if (!user || !user.password) {
      return res.status(401).json({ error: 'Invalid credentials' })
    }

    // Verify password
    const isValid = await bcrypt.compare(password, user.password)

    if (!isValid) {
      return res.status(401).json({ error: 'Invalid credentials' })
    }

    // Update last login
    await prisma.user.update({
      where: { id: user.id },
      data: { lastLogin: new Date() },
    })

    // Generate tokens
    const accessToken = generateAccessToken(user.id)
    const refreshToken = generateRefreshToken(user.id)

    res.json({
      user: {
        id: user.id,
        email: user.email,
        username: user.username,
        firstName: user.firstName,
        lastName: user.lastName,
      },
      accessToken,
      refreshToken,
    })
  } catch (error) {
    console.error('Login error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}
```

#### Task 3.4: OAuth Setup
Implement GitHub and Google OAuth using Passport.js

---

### üî¥ **PHASE 4: Bug Service Implementation** (Days 6-8)

#### Task 4.1: Setup Express Server
```bash
cd services/bug-service
npm init -y
npm install express cors helmet dotenv ioredis multer @prisma/client
npm install -D typescript @types/express @types/node ts-node-dev
```

#### Task 4.2: Redis Setup
**`src/utils/redis.ts`**:
```typescript
import Redis from 'ioredis'

const redis = new Redis(process.env.REDIS_URL!)

export const cacheKey = {
  bugs: (orgId: string, filters: any) => `bugs:${orgId}:${JSON.stringify(filters)}`,
  bug: (id: string) => `bug:${id}`,
}

export const cacheGet = async (key: string) => {
  const data = await redis.get(key)
  return data ? JSON.parse(data) : null
}

export const cacheSet = async (key: string, data: any, ttl: number = 300) => {
  await redis.setex(key, ttl, JSON.stringify(data))
}

export const cacheDelete = async (pattern: string) => {
  const keys = await redis.keys(pattern)
  if (keys.length > 0) {
    await redis.del(...keys)
  }
}

export default redis
```

#### Task 4.3: Bug Controller with Caching
**`src/controllers/bugController.ts`**:
```typescript
import { Request, Response } from 'express'
import { PrismaClient } from '@prisma/client'
import { cacheGet, cacheSet, cacheDelete, cacheKey } from '../utils/redis'

const prisma = new PrismaClient()

export const getBugs = async (req: Request, res: Response) => {
  try {
    const { organizationId, status, priority, assigneeId } = req.query
    const filters = { status, priority, assigneeId }

    // Try cache first
    const cacheKeyStr = cacheKey.bugs(organizationId as string, filters)
    const cached = await cacheGet(cacheKeyStr)

    if (cached) {
      return res.json({ bugs: cached, fromCache: true })
    }

    // Query database
    const bugs = await prisma.bug.findMany({
      where: {
        organizationId: organizationId as string,
        ...(status && { status: status as any }),
        ...(priority && { priority: priority as any }),
        ...(assigneeId && { assigneeId: assigneeId as string }),
      },
      include: {
        creator: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            avatar: true,
          },
        },
        assignee: {
          select: {
            id: true,
            username: true,
            firstName: true,
            lastName: true,
            avatar: true,
          },
        },
        comments: {
          take: 1,
          orderBy: { createdAt: 'desc' },
        },
      },
      orderBy: { createdAt: 'desc' },
    })

    // Cache for 5 minutes
    await cacheSet(cacheKeyStr, bugs, 300)

    res.json({ bugs, fromCache: false })
  } catch (error) {
    console.error('Get bugs error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

export const createBug = async (req: Request, res: Response) => {
  try {
    const { title, description, priority, organizationId, assigneeId } = req.body
    const creatorId = req.userId!

    const bug = await prisma.bug.create({
      data: {
        title,
        description,
        priority,
        organizationId,
        creatorId,
        assigneeId,
      },
      include: {
        creator: true,
        assignee: true,
      },
    })

    // Invalidate cache
    await cacheDelete(`bugs:${organizationId}:*`)

    // Emit socket event (we'll implement this later)
    // socket.emit('bug-created', bug)

    res.status(201).json({ bug })
  } catch (error) {
    console.error('Create bug error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}
```

#### Task 4.4: RBAC Middleware
**`src/middleware/rbac.ts`**:
```typescript
import { Request, Response, NextFunction } from 'express'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

export const checkOrgAccess = (requiredRole?: 'ADMIN' | 'DEVELOPER') => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const userId = req.userId!
      const organizationId = req.params.organizationId || req.body.organizationId

      const member = await prisma.organizationMember.findUnique({
        where: {
          userId_organizationId: {
            userId,
            organizationId,
          },
        },
      })

      if (!member) {
        return res.status(403).json({ error: 'Access denied' })
      }

      if (requiredRole === 'ADMIN' && member.role !== 'ADMIN') {
        return res.status(403).json({ error: 'Admin access required' })
      }

      if (requiredRole === 'DEVELOPER' && member.role === 'VIEWER') {
        return res.status(403).json({ error: 'Developer access required' })
      }

      req.organizationMember = member
      next()
    } catch (error) {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}
```

---

### üü£ **PHASE 5: Notification Service (Socket.io)** (Days 9-10)

#### Task 5.1: Setup Socket.io Server
```bash
cd services/notification-service
npm init -y
npm install express socket.io cors dotenv ioredis
npm install -D typescript @types/express @types/node ts-node-dev
```

#### Task 5.2: Socket Server Implementation
**`src/server.ts`**:
```typescript
import express from 'express'
import { createServer } from 'http'
import { Server } from 'socket.io'
import Redis from 'ioredis'
import jwt from 'jsonwebtoken'

const app = express()
const httpServer = createServer(app)

const io = new Server(httpServer, {
  cors: {
    origin: process.env.CORS_ORIGIN,
    credentials: true,
  },
})

const redis = new Redis(process.env.REDIS_URL!)
const redisPub = new Redis(process.env.REDIS_URL!)
const redisSub = new Redis(process.env.REDIS_URL!)

// Socket authentication
io.use((socket, next) => {
  const token = socket.handshake.auth.token

  if (!token) {
    return next(new Error('Authentication error'))
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as { userId: string }
    socket.data.userId = decoded.userId
    next()
  } catch (err) {
    next(new Error('Authentication error'))
  }
})

io.on('connection', (socket) => {
  console.log(`User connected: ${socket.data.userId}`)

  // Join organization room
  socket.on('join-organization', ({ organizationId }) => {
    socket.join(`org:${organizationId}`)
    socket.data.organizationId = organizationId
    
    // Notify others
    socket.to(`org:${organizationId}`).emit('user-joined', {
      userId: socket.data.userId,
    })
  })

  // Leave organization
  socket.on('leave-organization', ({ organizationId }) => {
    socket.leave(`org:${organizationId}`)
    
    socket.to(`org:${organizationId}`).emit('user-left', {
      userId: socket.data.userId,
    })
  })

  // Bug events
  socket.on('bug-created', (data) => {
    io.to(`org:${socket.data.organizationId}`).emit('bug-created', data)
  })

  socket.on('bug-updated', (data) => {
    io.to(`org:${socket.data.organizationId}`).emit('bug-updated', data)
  })

  socket.on('bug-deleted', (data) => {
    io.to(`org:${socket.data.organizationId}`).emit('bug-deleted', data)
  })

  // Comment events
  socket.on('comment-added', (data) => {
    io.to(`org:${socket.data.organizationId}`).emit('comment-added', data)
  })

  // Typing indicators
  socket.on('typing-start', (data) => {
    socket.to(`org:${socket.data.organizationId}`).emit('user-typing', {
      ...data,
      userId: socket.data.userId,
    })
  })

  socket.on('typing-stop', (data) => {
    socket.to(`org:${socket.data.organizationId}`).emit('user-stopped-typing', {
      ...data,
      userId: socket.data.userId,
    })
  })

  // Disconnect
  socket.on('disconnect', () => {
    if (socket.data.organizationId) {
      socket.to(`org:${socket.data.organizationId}`).emit('user-left', {
        userId: socket.data.userId,
      })
    }
    console.log(`User disconnected: ${socket.data.userId}`)
  })
})

// Redis pub/sub for multi-instance support
redisSub.subscribe('bug-events')
redisSub.on('message', (channel, message) => {
  const event = JSON.parse(message)
  io.to(`org:${event.organizationId}`).emit(event.type, event.data)
})

const PORT = process.env.PORT || 5003
httpServer.listen(PORT, () => {
  console.log(`üöÄ Notification service running on port ${PORT}`)
})
```

---

### üü¢ **PHASE 6: Frontend Integration** (Days 11-14)

#### Task 6.1: Install Required Packages
```bash
cd client
npm install @tanstack/react-query axios socket.io-client
npm install -D @tanstack/react-query-devtools
```

#### Task 6.2: Setup API Client
**`lib/api.ts`**:
```typescript
import axios from 'axios'

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
})

// Request interceptor to add token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

// Response interceptor for token refresh
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true

      try {
        const refreshToken = localStorage.getItem('refreshToken')
        const response = await axios.post(
          `${process.env.NEXT_PUBLIC_AUTH_URL}/auth/refresh`,
          { refreshToken }
        )

        const { accessToken } = response.data
        localStorage.setItem('accessToken', accessToken)

        originalRequest.headers.Authorization = `Bearer ${accessToken}`
        return api(originalRequest)
      } catch (err) {
        // Refresh failed, redirect to login
        localStorage.removeItem('accessToken')
        localStorage.removeItem('refreshToken')
        window.location.href = '/auth/login'
        return Promise.reject(err)
      }
    }

    return Promise.reject(error)
  }
)

export default api
```

#### Task 6.3: Setup React Query
**`app/providers.tsx`**:
```typescript
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { ThemeProvider } from 'next-themes'
import { useState } from 'react'

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000, // 1 minute
            refetchOnWindowFocus: false,
          },
        },
      })
  )

  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
        {children}
      </ThemeProvider>
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}
```

#### Task 6.4: Auth Context
**`hooks/useAuth.tsx`**:
```typescript
'use client'

import { createContext, useContext, useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import axios from 'axios'

interface User {
  id: string
  email: string
  username: string
  firstName?: string
  lastName?: string
}

interface AuthContextType {
  user: User | null
  login: (email: string, password: string) => Promise<void>
  register: (data: any) => Promise<void>
  logout: () => void
  isLoading: boolean
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const router = useRouter()

  useEffect(() => {
    // Check if user is logged in
    const token = localStorage.getItem('accessToken')
    if (token) {
      // Fetch user data
      axios
        .get(`${process.env.NEXT_PUBLIC_AUTH_URL}/auth/me`, {
          headers: { Authorization: `Bearer ${token}` },
        })
        .then((res) => setUser(res.data.user))
        .catch(() => localStorage.removeItem('accessToken'))
        .finally(() => setIsLoading(false))
    } else {
      setIsLoading(false)
    }
  }, [])

  const login = async (email: string, password: string) => {
    const response = await axios.post(
      `${process.env.NEXT_PUBLIC_AUTH_URL}/auth/login`,
      { email, password }
    )

    const { user, accessToken, refreshToken } = response.data
    localStorage.setItem('accessToken', accessToken)
    localStorage.setItem('refreshToken', refreshToken)
    setUser(user)
    router.push('/dashboard')
  }

  const register = async (data: any) => {
    const response = await axios.post(
      `${process.env.NEXT_PUBLIC_AUTH_URL}/auth/register`,
      data
    )

    const { user, accessToken, refreshToken } = response.data
    localStorage.setItem('accessToken', accessToken)
    localStorage.setItem('refreshToken', refreshToken)
    setUser(user)
    router.push('/dashboard')
  }

  const logout = () => {
    localStorage.removeItem('accessToken')
    localStorage.removeItem('refreshToken')
    setUser(null)
    router.push('/auth/login')
  }

  return (
    <AuthContext.Provider value={{ user, login, register, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  )
}

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}
```

#### Task 6.5: Socket.io Hook
**`hooks/useSocket.ts`**:
```typescript
import { useEffect, useState } from 'react'
import { io, Socket } from 'socket.io-client'
import { useQueryClient } from '@tanstack/react-query'

export function useSocket(organizationId?: string) {
  const [socket, setSocket] = useState<Socket | null>(null)
  const [connected, setConnected] = useState(false)
  const queryClient = useQueryClient()

  useEffect(() => {
    const token = localStorage.getItem('accessToken')
    if (!token) return

    const socketInstance = io(process.env.NEXT_PUBLIC_SOCKET_URL!, {
      auth: { token },
    })

    socketInstance.on('connect', () => {
      console.log('‚úÖ Socket connected')
      setConnected(true)

      if (organizationId) {
        socketInstance.emit('join-organization', { organizationId })
      }
    })

    socketInstance.on('disconnect', () => {
      console.log('‚ùå Socket disconnected')
      setConnected(false)
    })

    // Bug events - invalidate queries
    socketInstance.on('bug-created', () => {
      queryClient.invalidateQueries({ queryKey: ['bugs'] })
    })

    socketInstance.on('bug-updated', () => {
      queryClient.invalidateQueries({ queryKey: ['bugs'] })
    })

    socketInstance.on('bug-deleted', () => {
      queryClient.invalidateQueries({ queryKey: ['bugs'] })
    })

    socketInstance.on('comment-added', () => {
      queryClient.invalidateQueries({ queryKey: ['bugs'] })
    })

    setSocket(socketInstance)

    return () => {
      socketInstance.disconnect()
    }
  }, [organizationId, queryClient])

  return { socket, connected }
}
```

#### Task 6.6: Refactor Issues Page with Real Data
**`hooks/useBugs.ts`**:
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import api from '@/lib/api'

export function useBugs(organizationId: string, filters?: any) {
  return useQuery({
    queryKey: ['bugs', organizationId, filters],
    queryFn: async () => {
      const params = new URLSearchParams({
        organizationId,
        ...filters,
      })
      const response = await api.get(`/bugs?${params}`)
      return response.data.bugs
    },
    enabled: !!organizationId,
  })
}

export function useCreateBug() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (data: any) => {
      const response = await api.post('/bugs', data)
      return response.data.bug
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['bugs'] })
    },
  })
}

export function useUpdateBug() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: any }) => {
      const response = await api.patch(`/bugs/${id}`, data)
      return response.data.bug
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['bugs'] })
    },
  })
}

export function useDeleteBug() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      await api.delete(`/bugs/${id}`)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['bugs'] })
    },
  })
}
```

**Update `components/issues-page-content.tsx`**:
```typescript
'use client'

import { useState } from 'react'
import { motion } from 'framer-motion'
import { IssueTable } from '@/components/issue-table'
import { useBugs } from '@/hooks/useBugs'
import { useSocket } from '@/hooks/useSocket'
import { SkeletonLoader } from '@/components/skeleton-loader'

export function IssuesPageContent() {
  const [organizationId, setOrganizationId] = useState('your-org-id') // Get from context
  
  const { data: bugs, isLoading } = useBugs(organizationId)
  useSocket(organizationId) // Enable real-time updates

  if (isLoading) {
    return <SkeletonLoader count={5} />
  }

  return (
    <div>
      <IssueTable issues={bugs || []} />
    </div>
  )
}
```

#### Task 6.7: Add Framer Motion Animations
Add `layoutId` to bug cards for morphing effect:
```typescript
<motion.div
  layoutId={`bug-${bug.id}`}
  initial={{ opacity: 0 }}
  animate={{ opacity: 1 }}
  exit={{ opacity: 0 }}
>
  {/* Bug card content */}
</motion.div>
```

---

### üéØ **PHASE 7: Testing & Deployment** (Days 15-17)

#### Task 7.1: Write Tests
- Unit tests for all controllers
- Integration tests for API endpoints
- Frontend component tests

#### Task 7.2: Create Dockerfiles
Create `Dockerfile` for each service

#### Task 7.3: Setup CI/CD
Create `.github/workflows/ci.yml` for automated testing

#### Task 7.4: Production Deployment
- Deploy services to Railway/Render
- Deploy frontend to Vercel
- Setup environment variables
- Configure HTTPS

---

## üìä Estimated Timeline

| Phase | Tasks | Days | Status |
|-------|-------|------|--------|
| **Phase 1** | Project Setup | 2 | üî¥ Not Started |
| **Phase 2** | Database (Prisma) | 1 | üî¥ Not Started |
| **Phase 3** | Auth Service | 2 | üî¥ Not Started |
| **Phase 4** | Bug Service | 3 | üî¥ Not Started |
| **Phase 5** | Notification Service | 2 | üî¥ Not Started |
| **Phase 6** | Frontend Integration | 4 | üî¥ Not Started |
| **Phase 7** | Testing & Deployment | 3 | üî¥ Not Started |
| **TOTAL** | | **17 days** | |

---

## ‚úÖ Success Criteria

- [ ] All microservices running in Docker
- [ ] PostgreSQL database with complete schema
- [ ] Redis caching working (60% query reduction)
- [ ] JWT authentication with OAuth
- [ ] Full CRUD for bugs with RBAC
- [ ] Real-time updates via Socket.io
- [ ] Frontend connected to all backend services
- [ ] Framer Motion animations working
- [ ] Tests passing
- [ ] Deployed to production

---

## üöÄ Quick Commands Reference

```bash
# Start all services
docker-compose up --build

# Run migrations
docker-compose exec bug-service npx prisma migrate deploy

# Seed database
docker-compose exec bug-service npx prisma db seed

# View logs
docker-compose logs -f [service-name]

# Stop all services
docker-compose down

# Clean everything
docker-compose down -v
```

---

## üìù Notes

1. **Priority Order**: Follow phases in order - don't skip ahead
2. **Test as You Go**: Test each service before moving to the next
3. **Environment Variables**: Keep all secrets secure
4. **Documentation**: Update README as you build
5. **Git Commits**: Commit after each major feature

---

Ready to start building! üéâ
